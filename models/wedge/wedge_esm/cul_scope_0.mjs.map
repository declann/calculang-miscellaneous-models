{"version":3,"sources":["wedge.cul.js"],"names":["weight_y","coords_in","m_in","g_in","theta_in","coords","m","g","Math","cos","theta","weight_x","sin","F_x","F_y","a_x","a_y"],"mappings":"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","sourcesContent":["// start simple: inclined plane by theta, no friction\n\n// multiple coordinate systems => an input, though I might get here incrementally\n\n// scale fns in-calculang, like an early view model, this might get me thinking about patterning.\n// +will an input control scales to usual fns, rather than making bespoke fns?\n\n// w/o friction the net force on inclined plane is mg*sin(theta) [mg=weight or gravitational force]\n// => a = F/m = g*sin(theta) [along the inclined plane]\n\n// todo generalise rotation of (0, mg) force? (think rotation matrix)\n\nexport const weight_y = ({ coords_in, m_in, g_in, theta_in }) => {\n  if (coords({ coords_in }) == 'ground') return m({ m_in }) * g({ g_in });else\n  if (coords({ coords_in }) == 'plane')\n  return weight_y({ m_in, g_in, theta_in, coords_in: 'ground' }) * Math.cos(theta({ theta_in }));\n};\n\nexport const weight_x = ({ coords_in, m_in, g_in, theta_in }) => {\n  if (coords({ coords_in }) == 'ground') return 0;else\n  if (coords({ coords_in }) == 'plane')\n  return weight_y({ m_in, g_in, theta_in, coords_in: 'ground' }) * Math.sin(theta({ theta_in })); // notation development as-in Julia would benefit a lot here\n};\n\n// other forces: Normal reaction which offsets weight_y on 'plane'\n// friction(out)\n\n// => net force on 'plane' is (?, 0)\n// but on 'ground' is (?, ?)\n// weight_x is the only force contributing to the net force (weight_y is offset by normal)\n\n// F is net force\n// only use weight_x\nexport const F_x = ({ coords_in, m_in, g_in, theta_in }) => weight_x({ coords_in, m_in, g_in, theta_in });\n// convert weight_x 'plane' to 'ground', so weight_x works directly?\n\nexport const F_y = ({ coords_in, m_in, g_in, theta_in }) => {\n  if (coords({ coords_in }) == 'plane') return 0;\n  // necessary? This is where normal+weight_y would cancel\n  else if (coords({ coords_in }) == 'ground')\n  return weight_x({ m_in, g_in, theta_in, coords_in: 'plane' }) * Math.sin(theta({ theta_in })); // ?\n};\n// convert weight_x 'plane' to 'ground', so weight_x('plane') is manipulated\n\nexport const a_x = ({ coords_in, m_in, g_in, theta_in }) => F_x({ coords_in, m_in, g_in, theta_in }) / m({ m_in }); // ?\n\nexport const a_y = ({ coords_in, m_in, g_in, theta_in }) => F_y({ coords_in, m_in, g_in, theta_in }) / m({ m_in }); // ?\n\n//export const a = () => g() * Math.sin(theta()); // relative to inclined plane, no coord stuff happening yet\n\nexport const coords = ({ coords_in }) => coords_in; // 'plane' for inclined plane and 'ground'\nexport const theta = ({ theta_in }) => theta_in; // radians, 1 radian ~= 57 degrees, todo configurable\nexport const g = ({ g_in }) => g_in;\nexport const m = ({ m_in }) => m_in; // force depends on mass, but not accelaration\n// todo also generalise x,y directions"]}