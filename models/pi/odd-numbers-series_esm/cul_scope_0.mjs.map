{"version":3,"sources":["odd-numbers-series.cul.js"],"names":["range","sign","term_number_in","Math","pow","term_number","denominator","term","sum_of_terms","terms_in","terms","reduce","acc","pi_approximation"],"mappings":"AAAA;AACA;;AAEA,SAASA,KAAT,QAAsB,YAAtB;;AAEA;AACA;;;AAGA;AACA,OAAO,MAAMC,IAAI,GAAG,CAAC,EAAEC,cAAF,EAAD,KAAwBC,IAAI,CAACC,GAAL,CAAS,CAAC,CAAV,EAAaC,WAAW,CAAC,EAAEH,cAAF,EAAD,CAAX,GAAkC,CAA/C,CAArC;;AAEP;AACA,OAAO,MAAMI,WAAW,GAAG,CAAC,EAAEJ,cAAF,EAAD,KAAwB,CAACG,WAAW,CAAC,EAAEH,cAAF,EAAD,CAAX,GAAkC,CAAnC,IAAwC,CAAxC,GAA4C,CAAxF;;AAEP;AACA,OAAO,MAAMG,WAAW,GAAG,CAAC,EAAEH,cAAF,EAAD,KAAwBA,cAA5C;;AAEP;AACA,OAAO,MAAMK,IAAI,GAAG,CAAC,EAAEL,cAAF,EAAD,KAAwBD,IAAI,CAAC,EAAEC,cAAF,EAAD,CAAJ,IAA4B,IAAII,WAAW,CAAC,EAAEJ,cAAF,EAAD,CAA3C,CAArC;;AAEP;AACA,OAAO,MAAMM,YAAY,GAAG,CAAC,EAAEC,QAAF,EAAD,KAAkBT,KAAK,CAAC,CAAD,EAAIU,KAAK,CAAC,EAAED,QAAF,EAAD,CAAL,GAAsB,CAA1B,CAAL,CAAkCE,MAAlC;AAC9C,CAACC,GAAD,EAAMV,cAAN,KAAyBU,GAAG,GAAGL,IAAI,CAAC,EAAEL,cAAF,EAAD,CADW;AAE9C,CAF8C,CAAvC;;AAIP;AACA,OAAO,MAAMW,gBAAgB,GAAG,CAAC,EAAEJ,QAAF,EAAD,KAAkBD,YAAY,CAAC,EAAEC,QAAF,EAAD,CAAZ,GAA6B,CAAxE;;AAEP;AACA,OAAO,MAAMC,KAAK,GAAG,CAAC,EAAED,QAAF,EAAD,KAAkBA,QAAhC;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// leibniz formula for pi: https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80\n// watch: https://youtu.be/HrRMnzANHHs by Matt Parker (@standupmaths)\n\nimport { range } from 'underscore';\n\n// 1/1 - 1/3 + 1/5 - 1/7 + ... = pi/4\n// starting at 1 i.e. term 1 = 1/1, 2=-1/3, ...\n\n\n// alternating sign: +, -, +, -, ...\nexport const sign = ({ term_number_in }) => Math.pow(-1, term_number({ term_number_in }) - 1);\n\n// denominator from sequence of odd numbers\nexport const denominator = ({ term_number_in }) => (term_number({ term_number_in }) - 1) * 2 + 1;\n\n// input: number of current term\nexport const term_number = ({ term_number_in }) => term_number_in;\n\n// one term:\nexport const term = ({ term_number_in }) => sign({ term_number_in }) * (1 / denominator({ term_number_in }));\n\n// sum of terms (1 to terms input):\nexport const sum_of_terms = ({ terms_in }) => range(1, terms({ terms_in }) + 1).reduce(\n(acc, term_number_in) => acc + term({ term_number_in }),\n0);\n\n// pi approximation:\nexport const pi_approximation = ({ terms_in }) => sum_of_terms({ terms_in }) * 4;\n\n// input: total number of terms to sum\nexport const terms = ({ terms_in }) => terms_in;\n\n/*export const sum_of_terms = () => {\n  let res = 0, term_number_in = 1;\n  \n  while(term_number_in < terms()) {\n    res += term({term_number_in})\n    term_number_in++;\n  }\n\n  return res\n  }*/"]}